package controllers

import (
	"fmt"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	rufio "github.com/tinkerbell/rufio/api/v1alpha1"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"

	seederv1alpha1 "github.com/harvester/seeder/pkg/api/v1alpha1"
)

var _ = Describe("Inventory event controller tests", func() {
	var i *seederv1alpha1.Inventory
	var creds *corev1.Secret
	var ns *corev1.Namespace
	BeforeEach(func() {
		ns = &corev1.Namespace{
			ObjectMeta: metav1.ObjectMeta{
				Name: "event-test",
			},
		}

		i = &seederv1alpha1.Inventory{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "events",
				Namespace: "event-test",
			},
			Spec: seederv1alpha1.InventorySpec{
				PrimaryDisk:                   "/dev/sda",
				ManagementInterfaceMacAddress: "xx:xx:xx:xx:xx",
				BaseboardManagementSpec: rufio.MachineSpec{
					Connection: rufio.Connection{
						Host:        "localhost",
						Port:        623,
						InsecureTLS: true,
						AuthSecretRef: corev1.SecretReference{
							Name:      "events",
							Namespace: "event-test",
						},
					},
				},
				Events: seederv1alpha1.Events{
					Enabled:         true,
					PollingInterval: "2h",
				},
			},
		}

		creds = &corev1.Secret{
			ObjectMeta: metav1.ObjectMeta{
				Name:      "events",
				Namespace: "event-test",
			},
			StringData: map[string]string{
				"username": "root",
				"password": "calvin",
			},
		}

		Eventually(func() error {
			return k8sClient.Create(ctx, ns)
		}, "60s", "5s").ShouldNot(HaveOccurred())

		Eventually(func() error {
			return k8sClient.Create(ctx, creds)
		}, "30s", "5s").ShouldNot(HaveOccurred())

		Eventually(func() error {
			i.Spec.BaseboardManagementSpec.Connection.Host = redfishAddress
			return k8sClient.Create(ctx, i)
		}, "30s", "5s").ShouldNot(HaveOccurred())
	})

	It("check inventory and baremetal reconcile", func() {
		Eventually(func() error {
			iObj := &seederv1alpha1.Inventory{}
			if err := k8sClient.Get(ctx, types.NamespacedName{Namespace: i.Namespace, Name: i.Name}, iObj); err != nil {
				return err
			}
			iObj.Labels = map[string]string{
				seederv1alpha1.OverrideRedfishPortLabel: redfishPort,
			}
			return k8sClient.Update(ctx, iObj)

		}, "30s", "5s").ShouldNot(HaveOccurred())

		Eventually(func() error {
			iObj := &seederv1alpha1.Inventory{}
			err := k8sClient.Get(ctx, types.NamespacedName{Namespace: i.Namespace, Name: i.Name}, iObj)
			if err != nil {
				return err
			}

			if iObj.Status.Status != seederv1alpha1.InventoryReady {
				return fmt.Errorf("waiting for inventory to be ready. Current status %v", iObj)
			}
			return nil
		}, "30s", "5s").ShouldNot(HaveOccurred())

		Eventually(func() error {
			iObj := &seederv1alpha1.Inventory{}
			err := k8sClient.Get(ctx, types.NamespacedName{Namespace: i.Namespace, Name: i.Name}, iObj)
			if err != nil {
				return err
			}

			_, ok := iObj.Labels["manufacturer"]
			if !ok {
				return fmt.Errorf("waiting for manufacturer to be populated")
			}
			return nil
		}, "120s", "5s").ShouldNot(HaveOccurred())

		Eventually(func() error {
			el := &corev1.EventList{}
			err := k8sClient.List(ctx, el, &client.ListOptions{Namespace: i.Namespace})
			if err != nil {
				return err
			}

			if len(el.Items) == 0 {
				return fmt.Errorf("expected to find atleast 1 event generated by inventory event controller")
			}
			return nil
		}, "120s", "5s").ShouldNot(HaveOccurred())
	})

	AfterEach(func() {
		Eventually(func() error {
			return k8sClient.Delete(ctx, creds)

		}).ShouldNot(HaveOccurred())

		Eventually(func() error {
			return k8sClient.Delete(ctx, i)

		}).ShouldNot(HaveOccurred())

		Eventually(func() error {
			// wait until finalizers have cleaned up objects
			err := k8sClient.Get(ctx, types.NamespacedName{Namespace: i.Namespace, Name: i.Name}, i)
			if err != nil {
				// object is missing
				if apierrors.IsNotFound(err) {
					return nil
				}
			}
			return fmt.Errorf("waiting for inventory object to be not found")
		}).ShouldNot(HaveOccurred())

		Eventually(func() error {
			return k8sClient.Delete(ctx, ns)
		}).ShouldNot(HaveOccurred())
	})
})
